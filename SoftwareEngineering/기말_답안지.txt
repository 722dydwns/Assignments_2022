파일 이름은 본인 학번과 이름으로 수정한 후 작성하기 바랍니다.
총 18문제로 구성되었습니다.

******* 문제 시작 *******

1. 테스트 주도 개발(Test Driven Development)이 무엇인지 설명하고 장점을 나열하시오. (5점)
 
 테스트 주도 개발이란 테스팅과 코드 개발이 중첩되어 있는 개발 방식을 말하는 것인데, 
    즉, 점증적인 접근법으로 증분의 테스트를 저장하고 코드를 개발하는 방식이다. 

 장점은 모든 코드와 연관된 테스트를 실행시키기 때문에 개발 초기에 결함 발견이 용이하고,
회귀 테스팅 방식을 사용하여 모든 테스트를 반복적으로 테스팅하며,
단순화된 디버깅으로 문제를 지역화하기 쉽고, 시스템 문서화를 통해 테스트를 보면 코드를 이해하기 쉽다는 장점이 있다.

2. 회귀(regression) 테스팅과 스트레스(stress) 테스팅이 각각 무엇인지 기술하고 각각의 목적을 설명하시오. (6점)
 
회귀 테스팅이란 시스템을 변경한 후 변경과 관련된 테스트 뿐만 아니라 기존에 성공했던 모든 테스트를 실행하는 테스팅 기법으로서,
                  (목적)  변경으로 인하여 새로운 코드가 기존 코드와 문제없이 동작하는지를 반복적으로 검사하는 것이 목적이다. 

스트레스 테스팅이란, 일부러 시스템의 최대 설계 부하를 초과하는 요청을 생성하는 테스팅 기법으로서, 
                  (목적) 최대 부하 걸렸을 때만 보일 수 있는 '시스템의 결함 발견' 과 시스템의 장애 행동 관찰을 목적으로 사용한다.


3. 소프트웨어 재공학(software reengineering)이 무엇이며 어떤 활동들이 포함되는지 설명하시오. (4점)

소프트웨어 재공학이란 시스템의 전체 또는 일부를 재구조화하거나 다시 작성하는 방식으로, 기존 시스템의 기능은 변경하지 않고 시스템을 유지보수하기 쉽고 이해하기 쉽게하는 방식이다. 

소프트웨어 재공학 프로세스 활동에는 소스코드 변환, 역공학, 프로그램 모듈화, 데이터 재공학 등의 활동이 포함된다. 


4. 유지보수 유형을 수정(corrective) 유지보수, 적응(adaptive) 유지보수, 완전(perfective) 유지보수, 예방(preventive) 유지보수로 분류할 때 각각에 대하여 설명하시오. (4점)

수정 유지보수는 결함을 수리하는 방식으로 유지보수하는 방식이고, 
적응 유지보수는 새로운 환경, 새로운 요구사항에 적응하기 위해 유지보수하는 방식이며
완전 유지보수는 새로운 요구사항을 구현하거나 시스템의 구조와 기능을 구현하는 유지보수 방식이다.
예방 유지보수는 장애 변경 시 발생할 수 있는 문제를 감소시키기 위해 유지보수하는 방식이다. 



5. 확실성(dependability)의 주요 특성 5가지를 나열하고 간략하게 설명하시오. (10점)

 확실성에는 가용성, 신뢰성, 안전성, 보안성, 복원성 등 5가지 특성이 있다.

가용성은 '어떤 시점'에 시스템이 서비스를 제공할 확률에 대한 것이고,
신뢰성은 '어떤 기간'동안 시스템이 명세대로 정확하게 서비스를 제공할 확률에 대한 것이다.
안전성은 시스템이 사람 또는 환경에 손상을 주지 않는지에 대한 것이고,
보안성은 시스템이 우연하거나 의도적인 침입을 막을 수 있는지에 대한 것이며,
복원성은 시스템이 고장, 공격 등의 상황에서 주요 서비스를 작 유지할 수 있는지에 대한 것이다. 

6. 결함 회피(fault avoidance), 결함 감지 및 정정(fault detection & correction), 결함 내성(fault tolerance)이 무엇인지 설명하고 각각의 예를 드시오. (9점)
 
결함 회피란 소프트웨어 설계 및 구현 시, 프로그래밍 오류를 피하는 개발방식을 사용하여 시스템에 도입되는 결함을 최소화하는 방식이다.
   이를테면 오류 발생하기 쉬운 언어 구성요소의 사용을 최소화하는 방식이 그 예시가 된다. 

결함 감지 및 정정은 검증 및 확인 프로세스에서 프로그램이 운영을 위해 배치되기 전에 결함을 발견하고 제거하도록 설계하는 것을 의미한다.
 이를테면 체계적인 테스팅, 디버깅, 정적 분석이 그 예시가 된다.

결함 내성은 실행 중 결함이나 예상치 못한 시스템  행동을 알아내고 시스템 고장이 발생하지 않는 방식으로 관리되도록 시스템을 설계해야 하는 것으로, 
  결함이 있어도 시스템이 서비스를 계속 제공할 수 있는 능력이 있도록 시스템을 설계하는 것이 목적이다. 
이를테면 내장 런타임 검사에 기반하는 결함 내성을 시스템에 포함시키거나, 결함 내성 시트메 아키텍처 기술을 사용하여 시스템을 설계하는 방식을 이용할 수 있다.


7. 시스템의 운영 프로파일(operational profile)이 무엇인지 설명하시오. (2점)

운영 프로파일은 시스템이 실제로 사용되는 방식을 반영하여 시스템의 입력 유형과 해당 입력 유형의 발생 확률에 대한 '명세'를 작성해놓은 것이다.
이 방식은 기존 시스템 대체하는 경우에는 사용되는 방식을 알기 쉽지만,
새롭고 혁신적인 시스템 개발 시에는 사용되는 방식을 예측하기 어렵다는 특징이 있다. 


8. 안전성 공학에서 위험(hazard), 리스크(risk)가 무엇인지 설명하시오. (3점)

 위험은 사고의 원인이 되거나 기여할 수 있는 잠재적 요인이나 조건을 의미하고,
리스크는 위험이 사고를 낼 가능성에 대한 것으로, 위험 확률과 위험 심각도의 조합으로 그 가능성을 고려한다. 


9. 소프트웨어 재사용 접근 방법 중 소프트웨어 제품 라인(software product line)이 무엇인지 설명하시오. (2점)

소프트웨어 제품 라인이란 공통 아키텍처와 일반적인 기능을 제공하는 소프트웨어 애플리케이션의 집합으로서,
   일반 아키텍처와 공유된 컴포넌트들과 특정 고객 요구사항을 반영한 특확된 각 애플리케이션을 포함하는 애플리케이션의 집합이라고 할 수 있다.

이것은 새로운 요구사항 반영을 위해 몇 가지 컴포넌트의 설정, 추가적인 컴포넌트의 구현, 몇 가지 컴포넌트의 변경들을 포함할 수 있다.



10. 다단 클라이언트-서버 아키텍처(N-tier client-server architecture)가 무엇인지 구성요소 각각에 대한 설명을 포함하여 기술하시오. (8점)

 다단 클라이언트 서버-아키텍처의 구성요소에는 웹 브라우저, 웹 서버, 데이터베이스 서버 등 시스템을 3단 계층으로 분리하여 확장성을 높인 아키텍처이다. 

1단 (웹 브라우저)에서 (클라이언트) 표현하고, 
2단 (웹 서버)에서 애플리케이션 처리와 데이커 가공 처리를 거치며,
3단 (데이터베이스 서버)에서 데이터베이스 관련 처리를 수행하는 방식으로 수행된다.


11. CORBA(Common Object Request Broker Architecture)가 무엇인지 설명하고 늦은 바인딩(late binding) 또는 실행시간(runtime) 바인딩이 가능하다는 것은 무엇을 의미하는가? (6점)

 CORBA는 미들웨어 시스템 명세로, 분산 컴포넌트들에 의하여 사용될 수 있는 표준 서비스를 제공할 뿐 아니라
분산 컴포넌트 통신과 실행을 지원하는 미들웨어 개발을 가능하도록 하는 오픈 표준으로 의도되었다. 
 이 방식은 서비스 지향 아키텍처를 사용하는데, 배치 또는 실행 시까지 서비스의 바인딩을 연기할 수 있는 것을 두고, 

  배치 시까지 바인딩을 미룰 수 있다고 하여 '늦은 바인딩'이 가능하다고 설명하며,
 실행 시간까지 바인딩을 연기할 수 있다고 하여 '실행 시간 바인딩' 이 가능하다고 설명한다. 



12. 서비스 지향 아키텍처(Service-Oriented Architecture)에서 다루는 (웹)서비스의 특징이 무엇인지 설명하시오. (4점)

서비스 지향 아키텍처에서 다루는 웹 서비스의 특징은 서비스가 독립적이고 느슨하게 연결되어 있으며
외부 컴포넌트에 의존하지 않고, HTTP, SOAP 등 인터넷과 xml 기반 프로토콜을 이용하여 접근한다는 특징이 있다.
추가로 플랫폼 및 구현 언어에 독립적이라는 특징도 있다. 


13. 분산(distributed) 버전관리 시스템인 Git에서 commit, push, pull이 무엇인지 설명하시오. (6점)

 commit 이란 사용자가 변경 작업을 완료하여 개인 저장소를 갱신하는 것을 의미하고,
push는 개인저장소의 변경을 프로젝트 저장소에 반영하는 것을 의미하며,
pull은 프로젝트 저장소의 변경을 개인 저장소로 가져오는 것을 의미한다.


14. 버전관리에서 분기(branch)와 합병(병합, merge)이 무엇인지 설명하고 분기를 하는 목적을 한 가지 드시오. (5점)

분기는 동일한 컴포넌트에 대한 독립적 개발을 위해 코드라인을 생성하는 것이다. 
분기를 하는 목적은 새로운 코드라인을 독립적으로 개발하기 위한 것이다. 

병합은 서로 다른 코드라인의 버전을 병합하여 새로운 버전을 생성하는 방식이다. 


15. 버전관리에서 델타(delta)가 무엇이며 종류는 어떤 것이 있는지, 어떻게 활용되는지 설명하시오. (3점)

델타는 버전 간의 차이를 의미한다. 

델타에는 전향 델타와 후향 델타가 있다.
전향 델타는 가장 초기 버전을 완전하게 저장하고 이후 버전을 생성하기 위한 델타를 관리하는 방식이고,
후향 델타는 가장 최근 버전을 완전하게 저장하고 이전 버전을 생성하기 위한 델타를 관리하는 방식이다. 

이러한 델타(버전 간의 차이)를 활용하여 저장공간 관리를 할 수 있는데, 보통 컴포넌트의 버전을 저장한다.



16. 버전관리에서 태그(tag, 또는 label)이 무엇이며 어떻게 활용되는지 설명하시오. (3점)

태그는 식별을 쉽게하기 위해 붙이는 이름(별칭)이다.
이 태그를 사용하여 특정 베이스 라인을 찾아내는데 활용할 수 있다.

17. 다음 함수의 흐름 그래프(flow graph)를 그린 후 다음과 같은 형식으로 표현하시오. (10점)


  a) node 번호를 주석으로 코드 오른쪽에 붙임 (예: // 1 // 2)

void sortPerson(Person p[], int size) {
	int i, j, minIndex;
	Person temp;    //1
	for (i=0; i<size-1; i++) {  //2
		minIndex = i;   //3 
		for (j=i+1; j<size; j++) {  //4
			if (p[j].age <p[minIndex].age)  //5
				minIndex = j;   //6
		}
		if (minIndex != i) {  //7
			temp = p[i];    
			p[i] = p[minIndex];
			p[minIndex] = temp;   //8
		}
	}
}  // 9

  b) 그래프를 다음과 같은 형식으로 표현 (경로 표현이 아니고 각 node 별로 outgoing edge만 표시)

     예를 들어 1~4 node가 있고
     1에서 2로 edge와 1에서 3으로 가는 edge가 있고
     2에서 4로, 3에서 4로 가는 edge가 있으며
     4는 마지막 node인  경우
     1 -> 2, 3
     2 -> 4 
     3 -> 4
     4 -> 없음


답: 
1 -> 2
2 -> 3, 9
3 -> 4
4-> 5, 7
5 -> 4, 6
6 -> 4
7 -> 2, 8 
8 -> 2


18. 프로젝트를 구성하는 작업들이 아래와 같을 때 다음에 답하시오. (10점)

작업  소요기간 선행작업
T1        10
T2         5
T3        10        T1
T4        10        T1
T5        10        T2
T6        10        T3
T7        10        T4, T5
T8         5         T7

  a) 프로젝트의 최단 수행 기간과 임계 경로(critical path)에 속한 작업을 나열하시오.

  답 : 최단 수행 기간은 임계경로 길이로서 35일 이고,
  임계경로에 속한 작업은 T1 - T4 - T7 - T8 이다. 

  b) 프로젝트 지연없이 각 작업을 최대한 일찍/늦게 시작하려고 할 때 각 작업별 시작일을 2개씩 나열하시오.
      예를 들어 T1을 일찍 1일차에 할 수 있고 늦게 6일차에 할 수 있으면 다음과 같이 표현 (답과 관계없음)
       T1 : 1일, 6일

답 : 
T1 : 1일, 1일
T2 : 1일, 6일
T3 : 11일, 16일
T4 : 11일, 11일
T5 ; 6일, 11일
T6 : 21일, 26일
T7 : 21일, 21일
T8 : 31일, 31일


******* 문제 끝 *******
